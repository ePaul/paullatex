% \iffalse meta-comment
%
%<*package>
%%  (C) 2009 Paul Ebermann
%%
%%   Package gmdoc-enhance - Verbesserungen für gmdoc.
%%
%%   Die Datei gmdoc-enhance.dtx sowie die dazugehörige
%%   gmdoc-enhance.ins sowie die damit generierte
%%   gmdoc-enhance.sty stehen unter der
%%   "LaTeX Project Public License" (LPPL, zu finden
%%   unter http://www.latex-project.org/lppl/, sowie
%%   auch in den meisten TeX-Distributionen in
%%   texmf/docs/latex/base/lppl*.txt), Version 1.3b oder
%%   später (nach Wahl des Verwenders).
%%
%%   Der 'maintenance-status' ist (zur Zeit) 'author-maintained'.
%%   
%%   Das heißt u.a., die Dateien dürfen frei vertrieben werden,
%%   bei Änderungen (durch andere Personen als Paul Ebermann)
%%   ist aber der Name der Datei zu ändern.
%</package>
% \fi
%
% \iffalse
% ---------------------------------------------
%<package>\NeedsTeXFormat{LaTeX2e}[2003/12/01]%
% ----------------------------________________-----------------
%<package>\ProvidesPackage{gmdoc-enhance}[2009/02/20 v0.2 Verbesserungen fuer gmdoc.]%
% ----------------------------________________-----------------
% \fi
%
% \iffalse
% \fi
%
% \CheckSum{0}
%
% \GetFileInfo{gmdoc-enhance.sty}
%
% 
% \title{Das \pk{gmdoc-enhance}-Paket -- Verbesserungen für \pk{gmdoc}. \
%   \thanks{ Diese Dokumentation gehört zu \
%    \pk{gmdoc-enhance}~\fileversion, de~\filedate.}}
% \author{Paul Ebermann\thanks{\texttt{Paul-Ebermann@gmx.de}}}
%
% \maketitle
% 
% \begin{abstract}
%    Dieses Package basiert auf \pk{gmdoc} von Grzegorz
%   \textquoteleft Natror\textquoteright
%    Murzynowski zur Dokumentation von \LaTeXpar-Paketen und fügt ein
%    paar weitere nützliche Funktionen hinzu, wie Markierung der
%    inline-Kommentare als solche auch in Folgezeilen, sichtbare
%    Kommentare (auskommentierter Code), und die Möglichkeit, andere
%    \LaTeX-Dateien im normalen Modus einzubinden (anstatt im
%    \pk{gmdoc}-Modus).
% \end{abstract}
%
% \tableofcontents
%
% \section{Nutzer-Doku}
%
% ^^A etwas tricky ... wir wollen, dass beim
% ^^A reinen LaTeX-Durchlauf der Beispiel-Abschnitt
% ^^A übersprungen wird, also muss ein '\iffalse' da
% ^^A stehen. Beim Doku-Lauf soll dieser Trick nicht
% ^^A auftauchen, also können wir nicht den normalen
% ^^A verbatim-Modus nehmen ... wir brauchen also ein
% ^^A '\iffalse' drumrum. Jetzt wird aber auch das innere
% ^^A '\iffalse' interpretiert, wodurch wir dahinter zwei
% ^^A '\fi' brauchen. Am Ende des Beispiel-Abschnitts dann
% ^^A entsprechend zwei '\iffalse'. (Hmm, und jetzt soll bitte
% ^^A niemand versuchen, diesen '^^A'-Abschnitt hier mit '\iffalse'
% ^^A auszukommentieren ...)
% \iffalse
%<*beispiel>
\iffalse
% \fi\fi
%
% Das Paket sollte -- wie üblich -- mit '\usepackage' geladen werden:
% \begin{quote}
%   '\usepackage'\arg[optionen]'{gmdoc-enhance}'
% \end{quote}
% Es lädt selbst das \pk{gmdoc}-Paket, falls dieses nicht schon geladen
% ist. Falls man Optionen an dieses übergeben will, sollte man es vorher
% selbst laden. Ein vollständiges Beispiel gibt es in Abschnitt \ref{driver}.
%
% \subsection{Inline-Kommentare mit \%}
% Diese Funktion erfordert (im Vergleich zum normalen \pk{gmdoc}) keine
% Änderung der zu kommentierenden Datei
% \normalInlineComments (nur das Aktivieren), sondern ändert nur das Aussehen.
\beispiel\zeile% Bei \pk{gmdoc} kann jede Code-Zeile von
% einem Inline-Kommentar gefolgt werden, der dann normal gesetzt
% wird, mit hängendem Einzug. Zu diesem Inline-Kommentar gehören auch
% direkt anschließende Kommentarzeilen. (Hier ein solches Beispiel.)
%
% Dieses Paket ändert das Aussehen eines solchen
%  \InlineCommentsWithPercent Absatzes:
\beispiel\zeile% Jetzt wird der Inline-Kommentar mit etwas mehr Abstand
% gesetzt, und das '%'-Zeichen grau (falls \pk{color} geladen wurde).
% Wichtiger aber, in den Folge-Zeilen erscheint jeweils zu Beginn der
% Zeile eine Kommentar-Markierung, so dass man ihn nicht mit einer
% neuen Code-Zeile verwechseln kann.
%
%
% Aktivieren kann man die Funktion mit \TextUsage{\InlineCommentsWithPercent},
% welches ab der entsprechenden Stelle gilt (es wurde oben zwischen den beiden
% Code-Zeilen im Beispiel verwendet.
% Mit \TextUsage{\normalInlineComments} wird wieder auf den Normal-Modus
% zurückgeschaltet.
%
% Global aktivieren kann man diesen Modus mit der Paket-Option
% \TextUsage*{inline}.
%
% \subsection{Sichtbare Kommentare}
%
% Dieses Paket bietet die Möglichkeit, Teile des
% Quelltextes auszukommentieren, und diese dann auch so zu setzen (anstatt
% dass der auskommentierte Quelltext als Teil der Dokumentation aufgefasst
% wird).
% Dazu verwendet man im Quelltext:
%\begin{verbatim}
%%! \nicht\gebraucht% Und jetzt $e^{i\pi}=-1$.
%\end{verbatim}
% Dies ergibt etwas wie dies:
%! \nicht\gebraucht% Und jetzt $e^{i\pi}=-1$.
%
% Dieser Modus hat zwei Parameter:
% Mit \meta{marker} (ein einzelnes Zeichen, wahrscheinlich muss es
% Kategorie \catother (other) haben) markiert man im Quelltext das
% Auskommentieren, direkt nach dem '%'\footnote{oder ^^B
% was auch immer gerade der durch \cs{CodeDelim} festgelegte ^^B
% Markierer ist.}.
% Der Defaultwert (und im obigen Beispiel verwendet) ist '!'.
%
% \meta{Farbe} ist ein Parameter (oder zwei) für
% \TextUsage{\color}\footnote{ aus dem \pk{color}-Paket},
% um eine farbliche Markierung des auskommentierten Codes zu aktivieren.
% (Default ist keine farbliche Markierung.)
% 
% Die Paket-Option \TextUsage*{visible} aktiviert den Modus und legt
%  \meta{Farbe} auf '{blue}' fest, was meine bevorzugte Einstellung ist.
%
% Falls diese Einstellungen nicht zusagen, kann man (statt oder zusätzlich zur
% Option) die folgenden Makros verwenden:
% 
% \TextUsage{\activateVisibleComments} aktiviert den Modus, ohne etwas an
% \meta{marker} oder \meta{Farbe} zu ändern.
%
% \TextUsage{\setVisibleCommentChar}\arg{marker} legt \meta{marker} fest.
%
% \TextUsage{\setVisibleCommentColor}\meta{Farbe} legt \meta{Farbe} fest.
% \meta{Farbe} ist entweder von der Form \arg[model]\arg{farbe} (für eine
% Farbe in einem der von \pk{color} bereitgestellten Farbmodelle) oder
% \arg{farbname} für einen der vordefinieren Farbnamen. Beides wird einfach
% an der geeigneten Stelle an 'color' weitergegeben.
%
% Falls eine Farbe festgelegt wird, sollten auskommentierte Code-Stellen
% unbedingt mit einem '%' (und eventuell einem inline-Kommentar danach) beendet
% werden, weil die Farbmarkierung sich sonst fälschlicherweise in die
% nächste Zeile fortsetzt, sogar inklusive der Zeilennummer:
%
%! \auskommentiert
\nicht\auskommentiert
%
% Das ist offenbar nicht so gedacht, aber ich habe keinen (einfachen) Weg
% gefunden, das abzuschalten.
%
% \subsection{Input im normalen Modus}
%
%  Wenn man innerhalb eines \pk{gmdoc}-Dokumentes eine andere
%  Datei lädt, welche die normalen \LaTeX-Konventionen für '%' und Zeilenenden
%  verwendet, gibt es Chaos \dots
%
%  \TextUsage{\normalInput}\arg{dateiname} stellt die üblichen
% \LaTeX-Konventionen wieder her, lädt \meta{dateiname} (falls existent),
%  und stellt wieder auf den \pk{gmdoc}-Modus zurück.
%
%  Dies ist etwa nützlich, falls man eine Beispiel-Datei einlesen möchte,
%  um deren Ausgabe zu zeigen.
%
% Die Datei wird innerhalb einer Gruppe geladen -- alle nicht-globalen
% Zuweisungen darin gehen also verloren.
%
% ^^A ------------------------------
%
% \iffalse\iffalse
\fi
%</beispiel>
% \fi
%
% \section{Der Doku-Treiber für dieses Paket}
% \label{driver}
%
% Der Dokumentations-Treiber dient gleichzeitig als Beispiel für
% die Anwendung (und die Ausgabe) dieses Paketes.
%<*driver>
% Die Dokumentenklasse, mit 'draft'-Option, um zu lange Zeilen
% zu markieren. (Nicht als globale Option, weil sonst \pk{hyperref}
% seine Arbeit verweigert.)
\PassOptionsToClass{draft}{scrartcl}
\documentclass[idxtotoc]{scrartcl}

%
% Die Standard-Pakete ...
\usepackage[utf8x]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}



\let\orgshow\show% Irgendjemand oder etwas definiert '\show' um -- das ist
%  normalerweise ein \TeX-primitiv, und ich benutze es gelegentlich zum
% Debuggen meiner Pakete. Daher machen wir uns eine Kopie davon.

\usepackage[countalllines, withmarginpar, codespacesgrey]{gmdoc}% Wir laden
% \pk{gmdoc} mit ein paar Optionen: es sollen alle Zeilen gezählt werden,
% nicht nur Code-Linien (das heißt, man kann schnell die passende
% Quelltext-Stelle finden), im Rand sollen verwendete Makros angezeigt
% werden, und Leerzeichen im Code sollen grau markiert werden.
\usepackage[visible, inline]{gmdoc-enhance}% unser eigenes Paket, mit allen
% vorhandenen Optionen.
\renewcommand*{\EOFMark}{}% Das Zeichen \meta{eof} am
% Ende der Datei ist überflüssig, weg damit.


%! \def\marginpartt{\normalfont\fontseries{lc}\ttfamily}% Abgeschrieben aus
% \pk{gmdocc}, aber die Schrift ist bei mir offenbar nicht da. Schade.

\RecordChanges% Wir wollen eine Liste der Änderungen generieren.
\setcounter{IndexColumns}{2} % wir haben ein paar ziemlich lange Makronamen,
% die in dreispaltigem Modus nicht passen.

\begin{document}

%!   \catcode`\^=7%  In einigen Sprachen wurde '^' von \pk{Babel} aktiviert,
%  was für die \pk{gmdoc}-Verwendung etwas störend ist, da wir es für '^^A'
% und '^^B' benötigen. Also schalten wir es wieder auf die
%  Normalbedeutung (Superscript bzw. doppelt Escape) zurück. Für \pk{ngerman}
% macht Babel das nicht, daher auskommentiert.

   \MakeShortVerb*\'% Wir wollen \verb+'+ im Kommentar als
   % verbatim-Markierungs-Zeichen verwenden, mit sichtbaren Leerzeichen.
   \DocInput{\jobname.dtx}% Jetzt laden wir uns selbst im Doku-Modus.

\end{document}
%</driver>

%
% \StopEventually{\PrintChanges\PrintIndex}
%
% \section{Implementation}
%
%<*package>
%
% \subsection{Benötigte Pakete}
%
%  Da dieses Paket \pk{gmdoc} erweitert, müssen wir natürlich sicherstellen,
%  das es geladen wurde. Zum übergeben von Optionen sollte man es aber vorher
%  selbst laden.
\RequirePackage{gmdoc}[2008/10/04]%

% \subsection[Schönere Inline-Kommentare]{Inline-Kommentare \
%   mit \%-Markierung in den Fortsetzungs-Zeilen}
%
%
%  Hier das Nutzer-Makro dieses Abschnittes.
\newcommand*{\InlineCommentsWithPercent}{%
  \let\gmde@org@ifilrr = \ifilrr% Wir merken uns dir Original-Einstellung
% für Block- oder Flattersatz.
  \ilrrtrue% Wir schalten auf Flatter- statt Blocksatz für die
% Inline-Kommentare. Unsere aktiven Leerzeichen sind ja nicht variabel
% in der Länge (wirklich?), und wir wollen auch keine Zeilenumbrüche
% außerhalb von Leerzeichen (etwa durch Silbentrennung).
  \let\gmd@percenthack\gmde@percenthack% Außerdem verwenden wir unsere
% gepatchte Variante von '\gmd@percenthack'.
}%
% 
% Der Zurückschalter.
\newcommand*{\normalInlineComments}{%
  \let\ifilrr = \gmde@org@ifilrr% Wir setzen die Block/Flattersatz-Einstellung
%  zurück auf den Wert, der beim letzten '\InlineCommentsWithPercent' galt.
  \let\gmd@percenthack \gmde@org@percenthack% Dies setzen wir auf aufs
% Original zurück.
}%
% 
% Wir merken uns die Original-Version von '\gmd@percenthack', damit
% wir wieder zurückschalten können.
\let \gmde@org@percenthack = \gmd@percenthack%
%
% Das ist unsere Variante von '\gmd@percenthack'.
\def\gmde@percenthack{%
  \ifprevhmode%
% Bis hier was es auch im Original schon so.
     \aftergroup\gmde@specialSpaces% Diese Zeile ist neu -- wir schalten
% um auf unsere neu definierten aktiven Leerzeichen.
     \aftergroup\gmde@kommentarStart% Das Original war hier
% '\code@delim\aftergroup~'.
% 
% Der Rest ist wieder wie im Original.
   \else%
     \aftergroup\gmd@narrcheckifds@ne%
   \fi%
}%
%
%
%

% Zunächst ^^A \showthe\font
% \the\hyphenchar\font
% ^^A \expandafter\orgshow\csname gmde@hyphenreset\endcsname
% besorgen wir uns ein aktives Leerzeichen. Dafür schalten
% wir kurzfristig die Kategorie von ' ' um.
\catcode`\ =\active%
\def\gmde@activeSpace{ }%
\catcode`\ =10%

% '\gmde@specialSpaces' macht die Leerzeichen für den entsprechenden
% Paragraphen aktiv und legt auch ihre Bedeutung fest.
\def\gmde@specialSpaces{%
  \catcode`\ =\active% Aktives Leerzeichen.
  \@xa\let\gmde@activeSpace=\gmde@discrSpace% Und es soll die
% (unten definierte) Leerzeichenfunktion aufrufen.
  \exhyphenpenalty=0% Das setzt die Strafen für Umbrüche an diesen
% Leerzeichen (und ähnlichen '\discretionary's mit leerem
%"`Pre-break"'-Inhalt) auf 0.
  \hyphenpenalty=1000% Dafür stellen wir die Strafen für normale
% Silbentrennung hoch -- allerdings schalten wir auch den Bindestrich
% ab, so dass das eigentlich irrelevant sein sollte. Es beeinflusst auch
% andere '\discretionary's mit nichtleerem "`pre-break"'-Text, die
% vielleicht irgendjemand verwendet.
%
  \let\@codetonarrskip\gmde@codetonarrskip%  Wir sorgen dafür, dass mit
% dem nächsten Paragraphen das alles wieder abgeschaltet wird --
% '\gmde@codenarrskip' ruft (nach der normalen Aktion von '\@codetonarrskip')
% '\gmde@normalSpaces' auf.
% 
% Wir merken uns den alten '\hyphenchar', damit wir
% ihn später zurücksetzen können. 
  \def\@tempa{gmde@hyphenchar-%
    \@xa\string\the\font}% der Name für unsere zu definierende
  % Kontrollsequenz. Er enthält den internen Namen der Schrift.
  \@ifundefined{\@tempa}{%
% Die Nummer des '\hyphenchar's merken wir uns jetzt in dieser
% Kontrollsequenz.
    \@xa\edef\csname \@tempa\endcsname{%
      \the\hyphenchar\font }%
  }{% Wenn wir es schon vorher definiert haben,
% definieren wir es nicht noch einmal, denn dann ist jetzt vielleicht
% schon der Code $-1$, wogegen der Original-Code (meist 45) noch dort
% gespeichert ist.
  }%
  \edef\gmde@hyphenreset{%
    \hyphenchar\font=%
    \@xa\noexpand%
    \csname \@tempa\endcsname%
  }%
% Und jetzt setzen wir für diesen Absatz den '\hyphenchar' der aktuellen
% Schrift auf $-1$, um damit Trennungen an -, -- und --- sowie
% Silbentrennungen auszuschließen.
  \hyphenchar\font=-1 % Das ist
% aber trotzdem noch ein Hack, denn
% natürlich kann man \textsl{einfach -- zwischendurch -- in eine andere^^B
% Schriftart -- das ist jetzt ein Beispiel mit Hyphenchar ^^B
% \expandafter$\the\hyphenchar\font$ -- schalten}, die dann doch wieder einen
% echten '\hyphenchar' hat. (Nachher wieder
% \expandafter$\the\hyphenchar\font$.) Hmm,
% bessere  Vorschläge?
}%

% noch ein Vorgabewert für dieses Kommando ... es wird regelmäßig
% neu definiert, aber eventuell wird es vor der ersten solchen Definition
% noch geändert.
\def\gmde@hyphenreset{}%

% Das ist eine Sicherheitskopie von '\@codetonarrskip' aus \pk{gmdoc}.
\let\gmde@org@codetonarrskip = \@codetonarrskip%
% 
% Und jetzt unsere Variante, mit einem Aufruf der Rücksetzfunktion.
\let\gmde@codetonarrskip     = \@codetonarrskip
\g@addto@macro\gmde@codetonarrskip{\gmde@normalSpaces}%
% 

% Dieses Makro enthält eine Box, die am Start jeder Kommentarzeile
% gesetzt wird. 
\def\gmde@kommentarStart{%
% Hmm, wir könnten auch eine save-Box dafür reservieren,
% anstatt es immer neu zu bauen ... aber so passt es sich wenigstens
% an Änderungen des von '\code@delim' an.
  \hbox{{%
    \@ifpackageloaded{color}{\color{gray}}{}% Falls das \pk{color}-Paket
% geladen ist, zeigen wir das '%'-Zeichen in grau statt dem normalen
% schwarz. Damit sticht es nicht ganz so sehr ins Auge.
    \ttfamily\code@delim\quad}}%
}%


%
% Hier die Definition unseres merkwürdigen aktiven Leerzeichens.
%
% \dots Ein paar Zahlen: '\hyphenpenalty':
% \expandafter$\the\hyphenpenalty$, '\exhyphenpenalty': \expandafter$\the\exhyphenpenalty$
\def\gmde@discrSpace{%
  \ifx\protect\@typeset@protect%
    \ifinner%
        \space%  Wenn wir in einer inneren Box sind, soll das aktive
% Leerzeichen wie ein normales Leerzeichen funktionieren, da es ja
% hier sowieso keinen Zeilenumbruch gibt. Oder? Egal, unsere
% Code-Kommentare sollten nie im inneren Modus auftauchen.
    \else%
      \ifhmode%
        \unskip% Hmm, ich bin mir nicht ganz sicher, warum dieser
% Befehl hier notwendig ist. Ohne gibt es jedenfalls gelegentlich
% Zeilenumbrüche, die nicht an einen dieser '\discretionary's
% fallen (und entsprechend kein '%' in der nächsten Zeile haben.)
%
        \discretionary{% Die "`Expansion"' dieses '\discretionary'-Objektes
% falls es hier einen Zeilenumbruch gibt, ist am Ende der Zeile
% leer.
        }{\gmde@kommentarStart% Dafür taucht am Ende der vorherigen Zeile
% die Box auf, die durch '\gmd@kommentarStart' gesetzt wird.
        }{% Falls kein Umbruch an dieser Stelle erfolgte, ist es
% ebenfalls leer.
        }%
        ~% Jetzt setzen wir noch ein nicht-umbrechbares Leerzeichen. Falls
% es einen Umbruch gab, war der ja davor.
      \else% 
        \space% Außerhalb des horizontalen Modus (d.h. im Mathe- und im
% vertikalen Modus) hat unsere Spezialfunktion auch nichts
% zu suchen.
      \fi%
    \fi%
    \afterfi{%
      \gmde@gobbleActiveSpaces}% Am Ende fressen wir alle weiteren
% direkt       folgenden derartigen aktiven Leerzeichen auf, damit es nicht
% mehrere auf einmal gibt.
%
% Eigentlich sorgt das obige '\unskip' ja schon dafür, dass mehrere
% aufeinanderfolgende aktive Leerzeichen (die ja prinzipiell ein '~'
% als skip einfügen), keine Probleme bereiten, nur das letzte bleibt übrig.
% Damit ist das '\gmd@gobbleActiveSpaces' eigentlich nicht mehr
% nötig. Aber wir entlasten damit den Zeilenumbruch-Algorithmus
% etwas, wenn nicht mehrere '\discretionary's hintereinander kommen.
  \else%
    \space% Falls wir nicht im Typeset-Modus sind, sondern etwa in eine Datei
% oder auf den Bildschirm schreiben, soll unser ' ' auch wie ein normales
% Leerzeichen wirken. Schließlich findet da kein Zeilenumbruch statt.
  \fi%
}%
%
% Hier die Definition unseres Space-Fressers.
\def\gmde@gobbleActiveSpaces{%
  \@xa\@ifnextchar\gmde@activeSpace% Wir überprüfen, ob das
  % nächste Token ein aktives Leerzeichen ist.
  {% Falls ja, \dots
    \@xa\gmde@gobbleActiveSpaces\@gobble% entsorgen wir es
    % mit '\@gobble' und rufen uns dann selbst rekursiv auf.
  }{}% Im anderen Fall machen wir gar nichts, womit die Rekursion
  % beendet ist.
}%
%
% Dieses Makro setzt alles wieder aufs normale zurück.
\def\gmde@normalSpaces{%
  \gmde@hyphenreset% Wir rufen das Makro auf, welches den '\hyphenchar' auf
% seinen Original-Wert zurücksetzt.
  \exhyphenpenalty=50 \hyphenpenalty=50 % Die Strafen erhalten auch ihren normalen Wert.
  \@xa\let\gmde@activeSpace = \space% Das aktive Leerzeichen wird ein normales,
  \catcode`\           = 10%     und Leerzeichen sind ab jetzt nicht mehr
% aktiv.
  \let\@codetonarrskip  = \gmde@org@codetonarrskip% Wir setzen auch dieses
% Makro auf seine Original-Bedeutung zurück.
}%
%

%
% \subsection{Auskommentierter Quelltext}
%
% 
% Aktiviert den Sichtbar-Kommentar-Modus.
\newcommand*{\activateVisibleComments}{%
  \let \gmd@narrcheckifds = \gmde@narrcheckifds%
  \let \gmd@narrcheckifds@ne = \gmde@narrcheckifds@ne%
  \let \gmd@eatlspace = \gmde@eatlspace%
}
%
% Dieses Kommando legt das Zeichen zur sichtbaren Auskommentierung von
% Quelltext fest.
\newcommand*{\setVisibleCommentChar}[1]{%
  \let \gmde@visibleCommentChar = #1%
}%

% Hier ein Default-Wert für das Kommentar-Markierungs-Zeichen.
\setVisibleCommentChar{!}%

%
% Legt die  Farbe, in der sichtbare Kommentare gesetzt
% werden sollen, fest.
%
\newcommand*{\setVisibleCommentColor}{%
% Wir unterscheiden, ob ein optionales Argument gegeben
% wurde, und rufen entsprechend die passende Funktion auf.
  \@ifnextchar[\gmde@setVCColor@Opt% 
  \gmde@setVCColor@%
}%
% Nur, falls \pk{color} geladen wurde, macht der Farbumschalter
% etwas.
\def\gmde@setVCColor@#1{%
  \def\gmde@visibleCommentColor{\@ifpackageloaded{color}{\color{#1}}{}}%
}%
\def\gmde@setVCColor@Opt[#1]#2{%
  \def\gmde@visibleCommentColor{\@ifpackageloaded{color}{\color[#1]{#2}}}%
}%

% Der Default-Wert ist leer, also ohne Farbwechsel.
\let\gmde@visibleCommentColor\@empty

% Wir machen eine Sicherheitskopie der Original-Version
% von '\gmd@narrcheckifds'. Das ist ein Befehl, der nach
% einem '%' überprüft, ob das nächste Zeichen ein '<' ist,
% und dann eine Docstrip-Direktive setzt, andernfalls den
% normalen Erzählungs-Modus startet. Es gibt zwei Varianten
% davon, die mit '@ne' nimmt einen Parameter (der im
% "`Nicht-'<'-Fall"' ausgeführt wird), die andere nicht.
%
% Die beiden Makros werden aufgerufen, nachdem ein '%' am Anfang
% einer Zeile verarbeitet wurde - eines davon, wenn es vorher
% eine Code-Zeile gab, das andere nach einer Kommentarzeile.
\let\gmde@org@narrcheckifds = \gmd@narrcheckifds
\let\gmde@org@narrcheckifds@ne = \gmd@narrcheckifds@ne

% Eine neue Version von '\gmd@narrcheckifds'. Wir rufen einfach die Variante
% mit Parameter auf, wobei wir '\ignorespaces' übergeben. (Das ist beim
% Original ähnlich, allerdings dort einzeln analog implementiert.)
\def\gmde@narrcheckifds{%
  \gmde@narrcheckifds@ne{\ignorespaces}%
}%
% Die ein-Parameter-Version.
\def\gmde@narrcheckifds@ne#1{%
  \@ifnextchar\gmde@visibleCommentChar% Falls das nächste Zeichen
% unser Kommentarzeichen ist,
    \gmde@deactivatedCode% setzen wir den Rest als deaktivierten Code.
    {\gmde@org@narrcheckifds@ne{#1}}% Ansonsten rufen wir den
% Original-'<'-Test auf.
}%


% Das ist (zusammen mit dem nächsten Makro) der Kern von
% '\gmd@codstripdirective', den wir hier brauchen.
\def\gmde@deactivatedCode{%
  \gmd@textEOL% Wir tun so, als wäre das eine neue Zeile.
  \gmde@deactivatedcodePrefix%  Das wird als erstes Token an '\gmd@textEOL'
  % übergeben. Dadurch, dass es nur eines ist, wird es nicht als '%'
  % erkannt, sondern (nachdem wieder in den Verbatim-Modus gewechselt wurde)
  % ausgegeben.
}
%
% Was machen wir mit deaktiviertem Code (am Zeilenanfang)?
\def\gmde@deactivatedcodePrefix{%
  \gmde@visibleCommentColor% 
  \code@delim% Zunächst geben wir ein '%'-Zeichen aus.
  \@afternarrgfalse\@aftercodegtrue\@codeskipputgtrue% Diese boolean-Werte
% setzen wir, damit \TeX nachher weiß, wo es ist.
  \@firstoftwo% Und jetzt entsorgen wir das zweite
% folgende Token -- das ist das '!'-Zeichen. Das erste ist wohl
% irgendein Makro, welches wichtige Dinge anstellt - wenn wir das
% auch entsorgen, hört die Code-Formatierung nicht am nächsten '%'
% auf. Keine Ahnung, was das ist.
}%

%
%
% Hier eine leicht geänderte Version von '\gmd@eatlspace'.
% ('%' und '!' bezeichnen im Kommentar nicht unbedingt das entsprechende
% Zeichen, sondern das, was gerade als Code-Delimiter bzw.
% Visible-Comment-Marker festgelegt wurde (mit '%' und '!'
% als Default.)
% 
\def\gmde@eatlspace#1{%
  \ifx\gmd@texcodespace#1% Wenn das nächste Zeichen ein Leerzeichen, so \dots
    \advance\gmd@ldspaceswd by \gmd@spacewd% erhöhen wir die Einrückung,
% und \dots
    \afteriffifi{\gmde@eatlspace}% \dots wiederholen das ganze.
  \else%
    \if\code@delim\@nx#1% Wenn das nächste Zeichen '%' ist \dots
      \afterfifi{%
        \@ifnextchar\gmde@visibleCommentChar{% \dots und das folgende Zeichen
% ein '!', dann haben wir es mit einem sichtbaren Kommentar zu tun.
          \let\gmd@charbychar=\gmde@charbychar% Wir merken uns also, dass
          % dessen Präfix gezeigt werden muss, \dots
          \gmd@typesettexcode% \dots und rufen die normale Code-Formatierungs-Funktion auf, wobei das '!' dabei weggeworfen wird.
        }{%
% Ist das folgende Zeichen kein '!', so geht jetzt der Kommentar
% der letzten Zeile weiter (das kann entweder ein inline-Kommentar oder ein
% normaler sein).
          \gmd@ldspaceswd=\z@%
          \gmd@continuenarration#1%
        }%
      }%
    \else%
      % Ist das nächste Zeichen weder ' ' noch '%', so fängt hier der
      % Quelltext an.
      \afterfifi{\gmd@typesettexcode#1}%
    \fi%
  \fi%
}%

% Noch eine Sicherheitskopie: '\gmd@charbychar' geht zeichenweise
% durch den Code durch, mit Sonderbehandlung für '%', '\', das
% Dateiende sowie ein Zeilenende.
\let\gmde@org@charbychar\gmd@charbychar%

% Unsere Variante davon, die gesetzt wird, wenn die Zeile
% mit einem '%!' beginnt,
\def\gmde@charbychar{%
  \let\gmd@charbychar=\gmde@org@charbychar
  \gmde@deactivatedcodePrefix
  \gmd@charbychar%
}%

%
% \subsubsection{Etwas Test-Code}
%
%<*test>

bla
%<text>bedingter Text % mit Kommentar.
% mehr text % und Kommentar

% Komentar
%! das gleiche mit! % und Kommentar
  %! das gleiche mit! % und Kommentar
%! das gleiche mit! % und Kommentar
%
% Kommentar.
%</test>


% \subsection{Weitere Makros}


   \AtBeginDocument{\QueerCharOne}% \pk{inputenc} mit \pk{utf8x} definiert
% '^^A' um, so dass es Fehlermeldungen gibt. Also stellen wir die
% \pk{gmdoc}-Variante wieder her.



%
% Dieses Makro liest eine Datei im normalen \LaTeX-Modus ein, ohne komische
% EOL-Zeichen oder kaputte '%'.
\newcommand*{\normalInput}[1]{%
  % Wir packen alles in eine Gruppe, dann ist das Wiederherstellen der
  % Einstellungen nicht so schwer.
  \begin{StraightEOL}%
     \gmde@normalSpaces%
     \catcode`\%=14%
     \InputIfFileExists{#1}{}{}%
  \end{StraightEOL}%
}%
%

%
% \subsection{Verbatim-docstrip-Modus}
%
% Es wurde wohl vergessen, diese Variable zu initialisieren.
\let\gmd@docstripshook\@empty%
%
%<*test>
% Hier ein Test dafür:
%<<verbatim-modus
Irgenwas hier
%! auskommentiert % wirklich!
Noch mehr Muell % Hört das hier auf?
%
%verbatim-modus
%
% Hmm, das alleine reicht aber noch nicht, denke ich. Eigentlich sollte
% jetzt alles (bis zum erneuten auftauchen des Textes, der zwischen '<<' und
% dem Zeilenende stand) wörtlich ausgegeben werden, ohne Formatierungen.
%
% Naja, das baue ich vielleicht in einer späteren Version ein.
%</test>

% \subsection{Optionen des Paketes}
%
% Die Optionen rufen einfach die passenden Deklarationen auf.
%
\DeclareOption{visible}{%
  \setVisibleCommentColor{blue}%
  \activateVisibleComments%
}%
%
\DeclareOption{inline}{%
  \InlineCommentsWithPercent%
}%
% Jetzt veraarbeiten wir alle Optionen in der Reihenfolge, in
% der sie angegeben wurden. (Nicht, dass die Reihenfolge einen
% Unterschied machen sollte ...)
%
\ProcessOptions*\relax%
%
% Und damit sind wir fertig.
\endinput
%</package>
%
% \Finale
%\endinput


%%% Folgendes ist nur für meinen Editor.
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
